[back](documentation.md)

Version 5.00  
August 2025  
Chris Martin  

## Data files

- [Example data file](#ex)
- [The header](#head)
- [The data](#data)
- [Data file sizes](#size)
- [Calibrations](#cal)
---

LConfig includes two functions for creating data files: `lc_datafile_init()` and `lc_datafile_write()` described in the [api](api.md).  They are used in both the `lcburst` and `lcrun` [binaries](bin.md) to produce a standardized human-readable data file that embeds the configuration in a header.

### <a name="ex"></a> Example data file

A data file begins with the device configuration, ended by a `##`, followed by a time stamp, followed by the data.  This is an example of an ascii or text formatted data file.

```bash
# Configuration automatically generated by WRITE_CONFIG()
connection usb
device t4
name "My_T4_0888"
serial "440010888"
samplehz 2000.000000
settleus 1.000000
nsample 2000
dataformat ascii

# Analog Inputs
aichannel 0
ainegative 1
airange 1.000000
airesolution 0
aicalslope 20.000000
aicalzero 0.400000
aiunits "psi"
ailabel "Pressure"

distream 48

str:note0 "This is a note I added later."

## End Configuration ##
#: Sat Jun 22 21:02:12 2019
1.419444e+00	6.550400e+04
1.419444e+00	6.550400e+04
1.419444e+00	6.550400e+04
1.419444e+00	6.550400e+04
1.398734e+00	6.550400e+04
1.419444e+00	6.550400e+04
1.419444e+00	6.550400e+04
1.419444e+00	6.550400e+04
1.419444e+00	6.550400e+04
1.419444e+00	6.550400e+04
1.419444e+00	6.550400e+04
1.398734e+00	6.550400e+04
1.419444e+00	6.550400e+04
```

### <a name="head"></a> The header

The header is just a standard [configuration](config.md) terminated by the first appearance of `##`.  This gives a human reader or a post-processing code enough information to interpret the data that follow.  Meta parameters like `note0` can either be configured before data are collected, but the intent is also for users to be able to easily interject their own comments manually.  This makes it easier to keep notes on the fly while taking data.

The first line of the data also appears like a comment.  It always begins with `#:` and a space.  The following timestamp is a standard 24-character [time stamp](https://www.gnu.org/software/libc/manual/html_node/Formatting-Calendar-Time.html#Formatting-Calendar-Time).  It takes the form `DDD MMM dd hh:mm:ss YYYY` when D is the abbreviated day of the week, M is the abbreviated month, d is the calendar day of the month, h is the 24-hour clock hour, m is the minute, s is the second, and Y is the 4-digit year.

### <a name="data"></a> The data

LConfig supports saving data in binary or ascii formats based on the `dataformat` configuration parameter value.  Regardless, the header will always be encoded in plain ascii encoding, so it will be human readable using even the simplest command-line utilities.  Ironically, more sophisticated text editors will often try to determine the character encoding automatically, and will be confused by the appearance of binary data later in the file.

ASCII data are in exponential floating point tab-separated columns.  The data are formatted in exponential notation with seven significant figures (`%.6e` format) regardless of their source.  The end of a row is marked by a newline, `\n`.  

The ASCII column order is determined by the channels configured.  
- Analog inputs in the order they are configured  
- Extended feature channels in `stream` mode in the order they are configured  
- Digital input stream  

In binary format, after the timestamp (which is still encoded in ASCII characters), each data element is represented sequentially in the double precision floating point used by the system.  In many systems, this will be IEEE 754 big endian single-precision (32-bit) floating point number.  This means that each sample for each channel will occupy four bytes.  

The binary data order are identical to the ASCII data order, but they are sequential without separators or row breaks.  This is the same format used by the internal ring buffer, and it is understood by utilities like `lct_data()`.

As of version 5.00, all digital data are streamed as 16-bit unsigned integers, so 32-bit data is lost.  In the example above, the digital input stream returned a value 65,504 or 0b1111111111100000.  Only two digital inputs were configured (DIO4 and DIO5).  In these data, DIO4 was 0 and DIO5 was 1.  

### <a name="size"></a> Data file sizes

In ASCII format, a single sample from a single channel requires 13 characters (7 mantissa + 1 radix + 'e' + 3 exponent + 1 separator).  By contrast, binary needs only 32 bits for each data element, equivalent to only 4 characters.  Binary files are faster and obviously more efficient with space, but because their encoding may depend on the local system floating point implementation, ASCII has big advantages for archival value.  It is up to the user to decide which is more important.  

A compromise may be to use ASCII format and then use a separate file compression utility for long-term storage.  In practice, significant compression ratios can be achieved for ASCII-encoded files, because they are highly patterned.  

### <a name="cal"></a> Calibrations

In this example, the analog input configuration includes a calibration.  Calibrations are interpreted as being a conversion from volts to some unit (in this case, psi).  The data in the data file are always in volts as measured by the LabJack device.  It is up to post processing software to apply the calibration or not.  This has the advantage of making it easier to correct the data if the calibration turns out to be flawed.  Here, it looks like the pressure being measured is about (1.42 - 0.4)x20 = 20.4psi.

